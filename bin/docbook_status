#!/usr/bin/env ruby
# -*-encoding:utf-8 ; mode:ruby-*-
##
# docbook_status is the commandline application for the library.  Its
# main purpose is to display the structure and word counts for DocBook
# 5 documents. docbook_status can be used in single-run mode or
# demon-mode. In demon-mode it stays active and looks for changes in
# the filesystem.
#

require 'rubygems'
require "bundler/setup"
require 'optparse'
require 'directory_watcher'
require 'yaml'
require 'json'

require File.expand_path(File.join(File.dirname(__FILE__), %w[.. lib docbook_status]))

@demon = false
@glob = '*.xml'
@dir = '.'
@pre = []
@remarks = false
@remarks_filter = []
@output_format = :screen

banner = <<EOB
docbook_status, Version #{DocbookStatus.version}

Display DocBook 5 document structure and word counts.

Usage: docbook_status [options] <DOCBOOK-FILE>
EOB

opts = OptionParser.new
opts.banner = banner
opts.on('--demon', 'Keep running, act when files change') {|val| @demon = true}
opts.on('--glob PATTERN', String, 'File mask for demon mode, default = "*.xml"') {|val| @glob = val}
opts.on('--dir DIR', String, 'Source directory for demon mode, default = "." ') {|val| @dir = File.expand_path(val)}
opts.on('--pre COMMAND', String, 'A shell command that should be executed before') {|val| @pre << val}
opts.on('--remarks[=FILTER]', String, 'Show the remarks, comments. Use a keyword FILTER to restrict the listing') {|val|
  @remarks = true
  unless (val.nil? || val.empty?)
    @remarks_filter << val
  end
}
opts.on('--outputformat=yaml|json',['json','yaml'],'Return the result in YAML or JSON format instead of printing it') {|format|
  case
  when format == 'yaml'
    @output_format = :yaml
  when format == 'json'
    @output_format = :json
  else
    STDERR.puts "Unknown output format #{format}. Using screen output."
    @output = :screen
  end
}
rest = opts.parse(ARGV)

# Format the output for the screen and print it
#
def output_terminal(doc_info)
  puts
  puts "File:               #{doc_info[:name]}"
  puts "Modified:           #{doc_info[:ts]}"
  puts "Document structure:"
  puts "%-57.57s %-16s %5s" % ['Title','Tag','Words']
  puts "-"*80
  doc_info[:sections].each do |s|
    puts "%-57.57s %-16s %5d" % [(' ' * s[:level])+s[:title], s[:tag], s[:words]]
  end
  if doc_info[:remarks]
    puts
    puts "Remarks:"
    puts "%-10s %10s %5s %-52s" % %w[Type File Line Content]
    puts "-"*80
    doc_info[:remarks].each do |r|
      puts "%-10.10s %10s %5d %-52.52s" % ["#{r[:keyword]}",r[:file],r[:line],r[:text]]
    end
  end
end

# Processes the DocBook document once. Runs first all defined
# preprocessing (--pre) commands. Checks then for a DocBook namespace
# declaration, which would imply DocBook 5. If the namespaces include
# the XInclude-NS, XInclude-processing is started. At last the
# resulting document is analyzed.
#
def run(file)
  # OPTIMIZE Detailed output for --pre commands with popen4?
  @pre.each { |cmd|
    ret = system(cmd)
    unless ret
        STDERR.puts "Error: This preprocessing command signalled failure (#{$?}), please check --> #{cmd}"
        return
    end
  }
  dbs = DocbookStatus::Status.new(file)
  doc_info = dbs.analyze_file
  doc_info[:remarks] = dbs.find_remarks(@remarks_filter) if @remarks
  case
  when @output_format == :yaml
    YAML.dump(doc_info,STDOUT)
  when @output_format == :json
    puts doc_info.to_json
  else
    output_terminal(doc_info)
  end
end


# Demon routine for continuous processing of a DocBook document.
# This routine calls _run_ whenever the filesystem signals changes. To
# reduce load it waits for a defined time (interval * stable) before
# starting the actual processing.
#
def demon(file)
  dw = DirectoryWatcher.new @dir, :glob => @glob, :pre_load => true
  dw.interval = 5.0
  dw.stable = 2
  dw.persist = "dw_state.yml"
  dw.add_observer {|*args|
    args.each {|event|
      if event.type == :stable
        run(file)
      end
    }
  }
  dw.start    # loads state from dw_state.yml
  STDIN.gets  # when the user hits "enter" the script will terminate
  dw.stop     # stores state to dw_state.yml
end

# Print banner if called without arguments
if rest.length < 1
  puts opts.to_s
  exit 1
end

# The main routine
puts("docbook_status, Version #{DocbookStatus.version}") if @output_format == :screen
run(rest[0])
if (@demon)
  demon(rest[0])
end
exit 0
